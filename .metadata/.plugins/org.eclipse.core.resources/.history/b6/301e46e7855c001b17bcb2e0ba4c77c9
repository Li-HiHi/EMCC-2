/*
 * dev_control.cpp
 *
 *  Created on: 2020年11月23日
 *      Author: VULCAN
 */


#include "dev_control.hpp"


/*******************全局变量******************/
 float Kp_M=0,Ki_M=0,Kp_s_wd=0.0165,Kd_s_wd=0.01,Kp_s_zd=0.0165,Kd_s_zd=0.01,spd_M=35,spd_Ml=30,Kp_s,Kd_s;
 int foresight=60;
float errorS=0,errorS_1=0,steer_mid=7.65,steer_pwm=steer_mid,em_error=0,wd_flag=0;//舵机pid
int delay_sw=0;
extern int8_t em_sw;
int8_t image_sw=1;
float Motor_R=spd_M,Motor_L=spd_M,Motor_error_L=0,Motor_error_R=0,Motor_error_L1=0,Motor_error_R1=0,Motor_L_set=spd_M,Motor_R_set=spd_M;
float spd_R_Now,spd_L_Now;
float spdfix_R=1,spdfix_L=1;
float error=0;
int  turn_TH=20;//转弯临界点
int zebra_start_flag=0,zebra_finial_flag=1,zebra_delay=300;
/********************设置中断****************/

void Int_set(void)
{
    pitMgr_t::insert(6,0,my_Motor,pitMgr_t::enable);
    pitMgr_t::insert(20,1,my_steer,pitMgr_t::enable);
}


/*************中断服务函数****************/


void my_Motor(void *a)
{
    if(delay_sw==0||image_sw==0||zebra_finial_flag==0)
    {
        SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_0,20000,0);
           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_1,20000,0);
           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_2,20000,0);
           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_3,20000,0);
    }

    else
    {
        //反转保护并输出pwm
        if(Motor_R>0)
        {
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_0,20000,Motor_R);
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_1,20000,0);
        }
        else
        {
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_0,20000,0);
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_1,20000,-Motor_R);
        }
        if(Motor_L>0)
        {
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_2,20000,Motor_L);
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_3,20000,0);
        }
        else
        {
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_2,20000,0);
            SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_3,20000,-Motor_L);
        }



    }
    if(zebra_start_flag==1&&stop_flag==true)
    {


           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_0,20000,0);
           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_1,20000,0);
           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_2,20000,0);
           SCFTM_PWM_ChangeHiRes(FTM0,kFTM_Chnl_3,20000,0);
           zebra_finial_flag=0;
    }

    spd_R_Now=-SCFTM_GetSpeed(FTM2)*0.35;
    SCFTM_ClearSpeed(FTM2);
    spd_L_Now=SCFTM_GetSpeed(FTM1)*0.35;
    SCFTM_ClearSpeed(FTM1);




}
void my_steer(void *a)
{
    SCFTM_PWM_ChangeHiRes(FTM3,kFTM_Chnl_7,50,steer_pwm);
}


int My_Abs(int sta)
{
    if (sta >= 0)
    {
        return sta;
    }
    else
    {
        sta = 0-sta ;
        return sta;
    }
}



/***********控制舵机输出****************
 * 说明
 * 获取图像差值后进行pd控制
 * 使用分段参数，图像误差大于turn_TH+5时，进入弯道状态，反之直道状态,中间段为过渡部分
 *
 * ********/

int error_old=0;
void steerCTRL(void)
{

    errorS = get_image_error(foresight);//获取图像差值
    error=errorS;
    /*
    if(error_old!=0&&My_Abs(error-error_old)>=10)
    {
        error=error_old;
    }
    error_old=errorS;*/
    /**赛场保护*/
   if(get_image_error(60)==0)
       image_sw=0;
   else
       image_sw=1;


    /**电磁处理*/
  // LV_Sample();
  // LV_Get_Val();
   //em_error=get_EM_error();

   /***分段参数**/
   if(errorS> turn_TH+5||errorS < -turn_TH-5)
   {
       Kp_s=Kp_s_wd;
       Kd_s=Kd_s_wd;
       wd_flag=1;
   }
   else if(errorS < turn_TH&&errorS > -turn_TH)
   {
       Kp_s=Kp_s_zd;
       Kd_s=Kd_s_zd;
       wd_flag=0;
   }
   else
   {

       Kp_s=trans_error(errorS,Kp_s_wd,Kp_s_zd);
       Kd_s=trans_error(errorS,Kd_s_wd,Kd_s_zd);
       wd_flag=0.5;

   }


   steer_pwm=Kp_s*errorS+Kd_s*(errorS-errorS_1)+steer_mid;
   errorS_1=errorS;

    /**限幅*/
    if(steer_pwm<steer_mid-0.85)
        steer_pwm=steer_mid-0.85;
    else if(steer_pwm>steer_mid+0.85)
        steer_pwm=steer_mid+0.85;

}
/***************电机输出********************
 * 说明：
 * turn_TH为转弯临界值，大于此变化进入弯道状态，大参数转弯且低速；小于则直道状态，小参数用于稳定且高速
 *
 * 增量式PI控制
 *
 *增加过渡部分
 * ***/
void MotorCTRL(void)
{



   /********差速*****
    * **弯道低速*/
    if(errorS > turn_TH+5||errorS < -turn_TH-5)
    {
        Motor_L_set = spd_Ml*(1+spdfix_R*SpdFix(steer_pwm-steer_mid));
        Motor_R_set = spd_Ml*(1-spdfix_L*SpdFix(steer_pwm-steer_mid));
    }

    else
    {
        /**直道高速*/
        Motor_L_set = spd_M;
        Motor_R_set = spd_M;
    }

      //差值获取
    Motor_error_L=Motor_L_set-spd_L_Now;
    Motor_error_R=Motor_R_set-spd_R_Now;
      //pid控制
    Motor_L=Motor_L_set+Kp_M*(Motor_error_L-Motor_error_L1)+Ki_M*Motor_error_L;
    Motor_R=Motor_R_set+Kp_M*(Motor_error_R-Motor_error_R1)+Ki_M*Motor_error_R;


    Motor_error_R1=Motor_error_R;
    Motor_error_L1=Motor_error_L;


    /**限幅*/
    if(Motor_L>75)
        Motor_L=75;
    else if(Motor_L<-75)
            Motor_L=-75;
    if(Motor_R>75)
        Motor_R=75;
    else if(Motor_R<-75)
            Motor_R=-75;

}
/***************差速拟合计算*****************/
float SpdFix(float x)
{
    float spdfix=0;
    if(x>0)
    spdfix= -0.0523*x*x*x - 0.0123*x*x - 0.2711*x + 0.0041;
    if(x<0)
    spdfix=-0.0523*x*x*x + 0.0123*x*x - 0.2711*x - 0.0041;
    if(spdfix > 0.3 || spdfix < -0.3)
    {
        return 0;
    }
    return spdfix;
}

/****过渡部分线性计算***************/
float trans_error(float error,float high,float low)
{
    float x;
    if(error>0)
    {
        x = low+0.20*(high-low)*(error-(float)turn_TH);
        x = low+0.20*(high-low)*(error-(float)turn_TH);
    }
    if(error<0)
    {
        x = low+0.20*(high-low)*(-error-(float)turn_TH);
        x = low+0.20*(high-low)*(-error-(float)turn_TH);
    }
    return x;
}



/***************延时启动**********************/

void del_start(void)
{
    if(delay_sw==0)
    {
        DISP_SSD1306_delay_ms(1000);
        delay_sw=1;
    }
}

/**********斑马线控制**/
void zebra_CTRL(void)
{

if(zebra_start_flag==0&&steer_pwm>8)//经过一个弯道进入斑马线扫描状态
    zebra_start_flag=1;
/**其余控制在电机控制中断中*/
}


